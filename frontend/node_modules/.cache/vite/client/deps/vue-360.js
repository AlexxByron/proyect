import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/vue-360/dist/index.js
var require_dist = __commonJS({
  "node_modules/vue-360/dist/index.js"(exports, module) {
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function unwrapExports(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function createCommonjsModule(fn, module2) {
      return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
    }
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    var global_1 = (
      // eslint-disable-next-line no-undef
      check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func
      Function("return this")()
    );
    var fails = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    var descriptors = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
    var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
    var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : nativePropertyIsEnumerable;
    var objectPropertyIsEnumerable = {
      f
    };
    var createPropertyDescriptor = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    var toString = {}.toString;
    var classofRaw = function(it) {
      return toString.call(it).slice(8, -1);
    };
    var split = "".split;
    var indexedObject = fails(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classofRaw(it) == "String" ? split.call(it, "") : Object(it);
    } : Object;
    var requireObjectCoercible = function(it) {
      if (it == void 0) throw TypeError("Can't call method on " + it);
      return it;
    };
    var toIndexedObject = function(it) {
      return indexedObject(requireObjectCoercible(it));
    };
    var isObject = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
    var toPrimitive = function(input, PREFERRED_STRING) {
      if (!isObject(input)) return input;
      var fn, val;
      if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
      if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input))) return val;
      if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
    var hasOwnProperty = {}.hasOwnProperty;
    var has = function(it, key2) {
      return hasOwnProperty.call(it, key2);
    };
    var document$1 = global_1.document;
    var EXISTS = isObject(document$1) && isObject(document$1.createElement);
    var documentCreateElement = function(it) {
      return EXISTS ? document$1.createElement(it) : {};
    };
    var ie8DomDefine = !descriptors && !fails(function() {
      return Object.defineProperty(documentCreateElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
    var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (ie8DomDefine) try {
        return nativeGetOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };
    var objectGetOwnPropertyDescriptor = {
      f: f$1
    };
    var anObject = function(it) {
      if (!isObject(it)) {
        throw TypeError(String(it) + " is not an object");
      }
      return it;
    };
    var nativeDefineProperty = Object.defineProperty;
    var f$2 = descriptors ? nativeDefineProperty : function defineProperty2(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (ie8DomDefine) try {
        return nativeDefineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
    var objectDefineProperty = {
      f: f$2
    };
    var createNonEnumerableProperty = descriptors ? function(object, key2, value) {
      return objectDefineProperty.f(object, key2, createPropertyDescriptor(1, value));
    } : function(object, key2, value) {
      object[key2] = value;
      return object;
    };
    var setGlobal = function(key2, value) {
      try {
        createNonEnumerableProperty(global_1, key2, value);
      } catch (error) {
        global_1[key2] = value;
      }
      return value;
    };
    var SHARED = "__core-js_shared__";
    var store = global_1[SHARED] || setGlobal(SHARED, {});
    var sharedStore = store;
    var functionToString = Function.toString;
    if (typeof sharedStore.inspectSource != "function") {
      sharedStore.inspectSource = function(it) {
        return functionToString.call(it);
      };
    }
    var inspectSource = sharedStore.inspectSource;
    var WeakMap = global_1.WeakMap;
    var nativeWeakMap = typeof WeakMap === "function" && /native code/.test(inspectSource(WeakMap));
    var shared = createCommonjsModule(function(module2) {
      (module2.exports = function(key2, value) {
        return sharedStore[key2] || (sharedStore[key2] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: "3.6.5",
        mode: "global",
        copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
      });
    });
    var id = 0;
    var postfix = Math.random();
    var uid = function(key2) {
      return "Symbol(" + String(key2 === void 0 ? "" : key2) + ")_" + (++id + postfix).toString(36);
    };
    var keys = shared("keys");
    var sharedKey = function(key2) {
      return keys[key2] || (keys[key2] = uid(key2));
    };
    var hiddenKeys = {};
    var WeakMap$1 = global_1.WeakMap;
    var set;
    var get;
    var has$1;
    var enforce = function(it) {
      return has$1(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (nativeWeakMap) {
      store$1 = new WeakMap$1();
      wmget = store$1.get;
      wmhas = store$1.has;
      wmset = store$1.set;
      set = function(it, metadata) {
        wmset.call(store$1, it, metadata);
        return metadata;
      };
      get = function(it) {
        return wmget.call(store$1, it) || {};
      };
      has$1 = function(it) {
        return wmhas.call(store$1, it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return has(it, STATE) ? it[STATE] : {};
      };
      has$1 = function(it) {
        return has(it, STATE);
      };
    }
    var store$1;
    var wmget;
    var wmhas;
    var wmset;
    var STATE;
    var internalState = {
      set,
      get,
      has: has$1,
      enforce,
      getterFor
    };
    var redefine = createCommonjsModule(function(module2) {
      var getInternalState = internalState.get;
      var enforceInternalState = internalState.enforce;
      var TEMPLATE = String(String).split("String");
      (module2.exports = function(O, key2, value, options) {
        var unsafe = options ? !!options.unsafe : false;
        var simple = options ? !!options.enumerable : false;
        var noTargetGet = options ? !!options.noTargetGet : false;
        if (typeof value == "function") {
          if (typeof key2 == "string" && !has(value, "name")) createNonEnumerableProperty(value, "name", key2);
          enforceInternalState(value).source = TEMPLATE.join(typeof key2 == "string" ? key2 : "");
        }
        if (O === global_1) {
          if (simple) O[key2] = value;
          else setGlobal(key2, value);
          return;
        } else if (!unsafe) {
          delete O[key2];
        } else if (!noTargetGet && O[key2]) {
          simple = true;
        }
        if (simple) O[key2] = value;
        else createNonEnumerableProperty(O, key2, value);
      })(Function.prototype, "toString", function toString2() {
        return typeof this == "function" && getInternalState(this).source || inspectSource(this);
      });
    });
    var path = global_1;
    var aFunction = function(variable) {
      return typeof variable == "function" ? variable : void 0;
    };
    var getBuiltIn = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
    };
    var ceil = Math.ceil;
    var floor = Math.floor;
    var toInteger = function(argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };
    var min = Math.min;
    var toLength = function(argument) {
      return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
    };
    var max = Math.max;
    var min$1 = Math.min;
    var toAbsoluteIndex = function(index2, length) {
      var integer = toInteger(index2);
      return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
    };
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index2) {
          value = O[index2++];
          if (value != value) return true;
        }
        else for (; length > index2; index2++) {
          if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
    var indexOf = arrayIncludes.indexOf;
    var objectKeysInternal = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key2;
      for (key2 in O) !has(hiddenKeys, key2) && has(O, key2) && result.push(key2);
      while (names.length > i) if (has(O, key2 = names[i++])) {
        ~indexOf(result, key2) || result.push(key2);
      }
      return result;
    };
    var enumBugKeys = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    var hiddenKeys$1 = enumBugKeys.concat("length", "prototype");
    var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames2(O) {
      return objectKeysInternal(O, hiddenKeys$1);
    };
    var objectGetOwnPropertyNames = {
      f: f$3
    };
    var f$4 = Object.getOwnPropertySymbols;
    var objectGetOwnPropertySymbols = {
      f: f$4
    };
    var ownKeys = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys2 = objectGetOwnPropertyNames.f(anObject(it));
      var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
      return getOwnPropertySymbols ? keys2.concat(getOwnPropertySymbols(it)) : keys2;
    };
    var copyConstructorProperties = function(target, source) {
      var keys2 = ownKeys(source);
      var defineProperty2 = objectDefineProperty.f;
      var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
      for (var i = 0; i < keys2.length; i++) {
        var key2 = keys2[i];
        if (!has(target, key2)) defineProperty2(target, key2, getOwnPropertyDescriptor2(source, key2));
      }
    };
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    var isForced_1 = isForced;
    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    var _export = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED2, target, key2, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global_1;
      } else if (STATIC) {
        target = global_1[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global_1[TARGET] || {}).prototype;
      }
      if (target) for (key2 in source) {
        sourceProperty = source[key2];
        if (options.noTargetGet) {
          descriptor = getOwnPropertyDescriptor$1(target, key2);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key2];
        FORCED2 = isForced_1(GLOBAL ? key2 : TARGET + (STATIC ? "." : "#") + key2, options.forced);
        if (!FORCED2 && targetProperty !== void 0) {
          if (typeof sourceProperty === typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        redefine(target, key2, sourceProperty, options);
      }
    };
    var isArray = Array.isArray || function isArray2(arg) {
      return classofRaw(arg) == "Array";
    };
    var toObject = function(argument) {
      return Object(requireObjectCoercible(argument));
    };
    var createProperty = function(object, key2, value) {
      var propertyKey = toPrimitive(key2);
      if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
      else object[propertyKey] = value;
    };
    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {
      return !String(Symbol());
    });
    var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var WellKnownSymbolsStore = shared("wks");
    var Symbol$1 = global_1.Symbol;
    var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
    var wellKnownSymbol = function(name) {
      if (!has(WellKnownSymbolsStore, name)) {
        if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
        else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    var SPECIES = wellKnownSymbol("species");
    var arraySpeciesCreate = function(originalArray, length) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
    };
    var engineUserAgent = getBuiltIn("navigator", "userAgent") || "";
    var process = global_1.process;
    var versions = process && process.versions;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] + match[1];
    } else if (engineUserAgent) {
      match = engineUserAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = engineUserAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
      }
    }
    var engineV8Version = version && +version;
    var SPECIES$1 = wellKnownSymbol("species");
    var arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
      return engineV8Version >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES$1] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
    var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
    var isConcatSpreadable = function(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
    _export({ target: "Array", proto: true, forced: FORCED }, {
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = toLength(E.length);
            if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
    var aFunction$1 = function(it) {
      if (typeof it != "function") {
        throw TypeError(String(it) + " is not a function");
      }
      return it;
    };
    var functionBindContext = function(fn, that, length) {
      aFunction$1(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 0:
          return function() {
            return fn.call(that);
          };
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
    var push = [].push;
    var createMethod$1 = function(TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = indexedObject(O);
        var boundFunction = functionBindContext(callbackfn, that, 3);
        var length = toLength(self2.length);
        var index2 = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
        var value, result;
        for (; length > index2; index2++) if (NO_HOLES || index2 in self2) {
          value = self2[index2];
          result = boundFunction(value, index2, O);
          if (TYPE) {
            if (IS_MAP) target[index2] = result;
            else if (result) switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index2;
              case 2:
                push.call(target, value);
            }
            else if (IS_EVERY) return false;
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    var arrayIteration = {
      // `Array.prototype.forEach` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
      forEach: createMethod$1(0),
      // `Array.prototype.map` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.map
      map: createMethod$1(1),
      // `Array.prototype.filter` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.filter
      filter: createMethod$1(2),
      // `Array.prototype.some` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.some
      some: createMethod$1(3),
      // `Array.prototype.every` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.every
      every: createMethod$1(4),
      // `Array.prototype.find` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.find
      find: createMethod$1(5),
      // `Array.prototype.findIndex` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod$1(6)
    };
    var defineProperty = Object.defineProperty;
    var cache = {};
    var thrower = function(it) {
      throw it;
    };
    var arrayMethodUsesToLength = function(METHOD_NAME, options) {
      if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
      if (!options) options = {};
      var method = [][METHOD_NAME];
      var ACCESSORS = has(options, "ACCESSORS") ? options.ACCESSORS : false;
      var argument0 = has(options, 0) ? options[0] : thrower;
      var argument1 = has(options, 1) ? options[1] : void 0;
      return cache[METHOD_NAME] = !!method && !fails(function() {
        if (ACCESSORS && !descriptors) return true;
        var O = { length: -1 };
        if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
        else O[1] = 1;
        method.call(O, argument0, argument1);
      });
    };
    var $filter = arrayIteration.filter;
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
    var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
    _export({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    var arrayMethodIsStrict = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          throw 1;
        }, 1);
      });
    };
    var $forEach = arrayIteration.forEach;
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    var USES_TO_LENGTH$1 = arrayMethodUsesToLength("forEach");
    var arrayForEach = !STRICT_METHOD || !USES_TO_LENGTH$1 ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
    _export({ target: "Array", proto: true, forced: [].forEach != arrayForEach }, {
      forEach: arrayForEach
    });
    var aPossiblePrototype = function(it) {
      if (!isObject(it) && it !== null) {
        throw TypeError("Can't set " + String(it) + " as a prototype");
      }
      return it;
    };
    var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
        setter.call(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    var inheritIfRequired = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      ) objectSetPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
    var objectKeys = Object.keys || function keys2(O) {
      return objectKeysInternal(O, enumBugKeys);
    };
    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys2 = objectKeys(Properties);
      var length = keys2.length;
      var index2 = 0;
      var key2;
      while (length > index2) objectDefineProperty.f(O, key2 = keys2[index2++], Properties[key2]);
      return O;
    };
    var html = getBuiltIn("document", "documentElement");
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = document.domain && new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length = enumBugKeys.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    var objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : objectDefineProperties(result, Properties);
    };
    var whitespaces = "	\n\v\f\r                　\u2028\u2029\uFEFF";
    var whitespace = "[" + whitespaces + "]";
    var ltrim = RegExp("^" + whitespace + whitespace + "*");
    var rtrim = RegExp(whitespace + whitespace + "*$");
    var createMethod$2 = function(TYPE) {
      return function($this) {
        var string = String(requireObjectCoercible($this));
        if (TYPE & 1) string = string.replace(ltrim, "");
        if (TYPE & 2) string = string.replace(rtrim, "");
        return string;
      };
    };
    var stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
      start: createMethod$2(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
      end: createMethod$2(2),
      // `String.prototype.trim` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.trim
      trim: createMethod$2(3)
    };
    var getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    var defineProperty$1 = objectDefineProperty.f;
    var trim = stringTrim.trim;
    var NUMBER = "Number";
    var NativeNumber = global_1[NUMBER];
    var NumberPrototype = NativeNumber.prototype;
    var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;
    var toNumber = function(argument) {
      var it = toPrimitive(argument, false);
      var first, third, radix, maxCode, digits, length, index2, code;
      if (typeof it == "string" && it.length > 2) {
        it = trim(it);
        first = it.charCodeAt(0);
        if (first === 43 || first === 45) {
          third = it.charCodeAt(2);
          if (third === 88 || third === 120) return NaN;
        } else if (first === 48) {
          switch (it.charCodeAt(1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          digits = it.slice(2);
          length = digits.length;
          for (index2 = 0; index2 < length; index2++) {
            code = digits.charCodeAt(index2);
            if (code < 48 || code > maxCode) return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    if (isForced_1(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
      NumberWrapper = function Number2(value) {
        var it = arguments.length < 1 ? 0 : value;
        var dummy = this;
        return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
          NumberPrototype.valueOf.call(dummy);
        }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
      };
      for (keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (
        // ES3:
        "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(",")
      ), j = 0; keys$1.length > j; j++) {
        if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
          defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
        }
      }
      NumberWrapper.prototype = NumberPrototype;
      NumberPrototype.constructor = NumberWrapper;
      redefine(global_1, NUMBER, NumberWrapper);
    }
    var NumberWrapper;
    var keys$1;
    var j;
    var key;
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    var toStringTagSupport = String(test) === "[object z]";
    var TO_STRING_TAG$1 = wellKnownSymbol("toStringTag");
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key2) {
      try {
        return it[key2];
      } catch (error) {
      }
    };
    var classof = toStringTagSupport ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
    };
    var objectToString = toStringTagSupport ? {}.toString : function toString2() {
      return "[object " + classof(this) + "]";
    };
    if (!toStringTagSupport) {
      redefine(Object.prototype, "toString", objectToString, { unsafe: true });
    }
    var regexpFlags = function() {
      var that = anObject(this);
      var result = "";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.dotAll) result += "s";
      if (that.unicode) result += "u";
      if (that.sticky) result += "y";
      return result;
    };
    function RE(s, f2) {
      return RegExp(s, f2);
    }
    var UNSUPPORTED_Y = fails(function() {
      var re = RE("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") != null;
    });
    var BROKEN_CARET = fails(function() {
      var re = RE("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") != null;
    });
    var regexpStickyHelpers = {
      UNSUPPORTED_Y,
      BROKEN_CARET
    };
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = String.prototype.replace;
    var patchedExec = nativeExec;
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      nativeExec.call(re1, "a");
      nativeExec.call(re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;
    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match2, i;
        var sticky = UNSUPPORTED_Y$1 && re.sticky;
        var flags = regexpFlags.call(re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = flags.replace("y", "");
          if (flags.indexOf("g") === -1) {
            flags += "g";
          }
          strCopy = String(str).slice(re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match2 = nativeExec.call(sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match2) {
            match2.input = match2.input.slice(charsAdded);
            match2[0] = match2[0].slice(charsAdded);
            match2.index = re.lastIndex;
            re.lastIndex += match2[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match2) {
          re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match2 && match2.length > 1) {
          nativeReplace.call(match2[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0) match2[i] = void 0;
            }
          });
        }
        return match2;
      };
    }
    var regexpExec = patchedExec;
    _export({ target: "RegExp", proto: true, forced: /./.exec !== regexpExec }, {
      exec: regexpExec
    });
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
    });
    var INCORRECT_NAME = nativeToString.name != TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      redefine(RegExp.prototype, TO_STRING, function toString2() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f2 = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? regexpFlags.call(R) : rf);
        return "/" + p + "/" + f2;
      }, { unsafe: true });
    }
    var SPECIES$2 = wellKnownSymbol("species");
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REPLACE = wellKnownSymbol("replace");
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var fixRegexpWellKnownSymbolLogic = function(KEY, length, exec, sham) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES$2] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          if (regexp.exec === regexpExec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
            }
            return { done: true, value: nativeMethod.call(str, regexp, arg2) };
          }
          return { done: false };
        }, {
          REPLACE_KEEPS_$0,
          REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
        });
        var stringMethod = methods[0];
        var regexMethod = methods[1];
        redefine(String.prototype, KEY, stringMethod);
        redefine(
          RegExp.prototype,
          SYMBOL,
          length == 2 ? function(string, arg) {
            return regexMethod.call(string, this, arg);
          } : function(string) {
            return regexMethod.call(string, this);
          }
        );
      }
      if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
    };
    var createMethod$3 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
        first = S.charCodeAt(position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    var stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$3(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$3(true)
    };
    var charAt = stringMultibyte.charAt;
    var advanceStringIndex = function(S, index2, unicode) {
      return index2 + (unicode ? charAt(S, index2).length : 1);
    };
    var regexpExecAbstract = function(R, S) {
      var exec = R.exec;
      if (typeof exec === "function") {
        var result = exec.call(R, S);
        if (typeof result !== "object") {
          throw TypeError("RegExp exec method returned something other than an Object or null");
        }
        return result;
      }
      if (classofRaw(R) !== "RegExp") {
        throw TypeError("RegExp#exec called on incompatible receiver");
      }
      return regexpExec.call(R, S);
    };
    var max$1 = Math.max;
    var min$2 = Math.min;
    var floor$1 = Math.floor;
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    fixRegexpWellKnownSymbolLogic("replace", 2, function(REPLACE2, nativeReplace2, maybeCallNative, reason) {
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
      var REPLACE_KEEPS_$02 = reason.REPLACE_KEEPS_$0;
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE2];
          return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace2.call(String(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
        function(regexp, replaceValue) {
          if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 && REPLACE_KEEPS_$02 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
            var res = maybeCallNative(nativeReplace2, regexp, this, replaceValue);
            if (res.done) return res.value;
          }
          var rx = anObject(regexp);
          var S = String(this);
          var functionalReplace = typeof replaceValue === "function";
          if (!functionalReplace) replaceValue = String(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regexpExecAbstract(rx, S);
            if (result === null) break;
            results.push(result);
            if (!global2) break;
            var matchStr = String(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = String(result[0]);
            var position = max$1(min$2(toInteger(result.index), S.length), 0);
            var captures = [];
            for (var j2 = 1; j2 < result.length; j2++) captures.push(maybeToString(result[j2]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = [matched].concat(captures, position, S);
              if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
              var replacement2 = String(replaceValue.apply(void 0, replacerArgs));
            } else {
              replacement2 = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += S.slice(nextSourcePosition, position) + replacement2;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + S.slice(nextSourcePosition);
        }
      ];
      function getSubstitution(matched, str, position, captures, namedCaptures, replacement2) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }
        return nativeReplace2.call(replacement2, symbols, function(match2, ch) {
          var capture;
          switch (ch.charAt(0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return str.slice(0, position);
            case "'":
              return str.slice(tailPos);
            case "<":
              capture = namedCaptures[ch.slice(1, -1)];
              break;
            default:
              var n = +ch;
              if (n === 0) return match2;
              if (n > m) {
                var f2 = floor$1(n / 10);
                if (f2 === 0) return match2;
                if (f2 <= m) return captures[f2 - 1] === void 0 ? ch.charAt(1) : captures[f2 - 1] + ch.charAt(1);
                return match2;
              }
              capture = captures[n - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      }
    });
    var domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    for (COLLECTION_NAME in domIterables) {
      Collection = global_1[COLLECTION_NAME];
      CollectionPrototype = Collection && Collection.prototype;
      if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
        createNonEnumerableProperty(CollectionPrototype, "forEach", arrayForEach);
      } catch (error) {
        CollectionPrototype.forEach = arrayForEach;
      }
    }
    var Collection;
    var CollectionPrototype;
    var COLLECTION_NAME;
    var uuidv1 = require_v1();
    var script = {
      name: "I360Viewer",
      props: {
        imagePath: {
          type: String,
          require: true,
          default: ""
        },
        fileName: {
          type: String,
          require: true,
          default: ""
        },
        spinReverse: {
          type: Boolean,
          require: true,
          default: false
        },
        amount: {
          type: Number,
          require: true,
          default: 24
        },
        autoplay: {
          type: Boolean,
          require: false,
          default: false
        },
        loop: {
          type: Number,
          require: false,
          default: 1
        },
        boxShadow: {
          type: Boolean,
          require: false,
          default: false
        },
        buttonClass: {
          type: String,
          require: false,
          default: "light"
        },
        hotspots: {
          type: Array,
          require: true,
          default: function _default() {
            return [];
          }
        },
        identifier: {
          type: String,
          require: true,
          default: function _default() {
            return uuidv1();
          }
        },
        paddingIndex: {
          type: Boolean,
          require: false,
          default: false
        },
        disableZoom: {
          type: Boolean,
          require: false,
          default: false
        },
        scrollImage: {
          type: Boolean,
          require: false,
          default: false
        }
      },
      data: function data2() {
        return {
          minScale: 0.5,
          maxScale: 4,
          scale: 0.2,
          customOffset: 10,
          currentScale: 1,
          currentTopPosition: 0,
          currentLeftPosition: 0,
          selectMenuOption: 1,
          currentImage: null,
          dragging: false,
          canvas: null,
          ctx: null,
          dragStart: null,
          lastX: 0,
          lastY: 0,
          currentCanvasImage: null,
          isFullScreen: false,
          viewPortElementWidth: null,
          movementStart: 0,
          movement: false,
          dragSpeed: 150,
          speedFactor: 13,
          activeImage: 1,
          stopAtEdges: false,
          imagesLoaded: false,
          loadedImages: 0,
          centerX: 0,
          centerY: 0,
          panmode: false,
          isMobile: false,
          currentLoop: 0,
          loopTimeoutId: 0,
          images: [],
          imageData: [],
          playing: false
        };
      },
      watch: {
        currentLeftPosition: function currentLeftPosition(value) {
          this.redraw();
        },
        currentTopPosition: function currentTopPosition(value) {
          this.redraw();
        },
        viewPortElementWidth: function viewPortElementWidth(value) {
          this.update();
        },
        panmode: function panmode(value) {
          this.attachEvents();
        },
        isFullScreen: function isFullScreen(value) {
          if (!value) {
            this.$refs.viewerContainer.classList.remove("v360-main");
            this.$refs.viewerContainer.classList.remove("v360-fullscreen");
          } else {
            this.$refs.viewerContainer.classList.add("v360-main");
            this.$refs.viewerContainer.classList.add("v360-fullscreen");
          }
          this.setImage();
        },
        playing: function playing(value) {
          if (value) {
            this.play();
          } else {
            this.stop();
          }
        }
      },
      mounted: function mounted() {
        this.fetchData();
        document.addEventListener("fullscreenchange", this.exitHandler);
        document.addEventListener("webkitfullscreenchange", this.exitHandler);
        document.addEventListener("mozfullscreenchange", this.exitHandler);
        document.addEventListener("MSFullscreenChange", this.exitHandler);
      },
      methods: {
        initData: function initData() {
          this.checkMobile();
          this.loadInitialImage();
          this.canvas = this.$refs.imageContainer;
          this.ctx = this.canvas.getContext("2d");
          this.attachEvents();
          window.addEventListener("resize", this.resizeWindow);
          this.resizeWindow();
          this.playing = this.autoplay;
        },
        fetchData: function fetchData() {
          for (var i = 1; i <= this.amount; i++) {
            var imageIndex = this.paddingIndex ? this.lpad(i, "0", 2) : i;
            var fileName = this.fileName.replace("{index}", imageIndex);
            var filePath = "".concat(this.imagePath, "/").concat(fileName);
            this.imageData.push(filePath);
          }
          this.preloadImages();
        },
        lpad: function lpad(str, padString, length) {
          str = str.toString();
          while (str.length < length) {
            str = padString + str;
          }
          return str;
        },
        preloadImages: function preloadImages() {
          var _this = this;
          if (this.imageData.length) {
            try {
              this.amount = this.imageData.length;
              this.imageData.forEach(function(src) {
                _this.addImage(src);
              });
            } catch (error) {
              console.error("Something went wrong while loading images: ".concat(error.message));
            }
          } else {
            console.log("No Images Found");
          }
        },
        addImage: function addImage(resultSrc) {
          var image = new Image();
          image.src = resultSrc;
          image.onload = this.onImageLoad.bind(this);
          image.onerror = this.onImageLoad.bind(this);
          this.images.push(image);
        },
        onImageLoad: function onImageLoad(event) {
          var percentage = Math.round(this.loadedImages / this.amount * 100);
          this.loadedImages += 1;
          this.updatePercentageInLoader(percentage);
          if (this.loadedImages === this.amount) {
            this.onAllImagesLoaded(event);
          } else if (this.loadedImages === 1) {
            console.log("load first image");
          }
        },
        updatePercentageInLoader: function updatePercentageInLoader(percentage) {
          this.$refs.viewPercentage.innerHTML = percentage + "%";
        },
        onAllImagesLoaded: function onAllImagesLoaded(e) {
          this.imagesLoaded = true;
          this.initData();
        },
        togglePlay: function togglePlay() {
          this.playing = !this.playing;
        },
        play: function play() {
          var _this2 = this;
          this.loopTimeoutId = window.setInterval(function() {
            return _this2.loopImages();
          }, 100);
        },
        onSpin: function onSpin() {
          if (this.playing || this.loopTimeoutId) {
            this.stop();
          }
        },
        stop: function stop() {
          if (this.activeImage == 1) {
            this.currentLoop = 0;
          }
          this.playing = false;
          window.clearTimeout(this.loopTimeoutId);
        },
        loopImages: function loopImages() {
          if (this.activeImage == 1) {
            if (this.currentLoop == this.loop) {
              this.stop();
            } else {
              this.currentLoop++;
              this.next();
            }
          } else {
            this.next();
          }
        },
        next: function next() {
          this.spinReverse ? this.turnLeft() : this.turnRight();
        },
        prev: function prev() {
          this.spinReverse ? this.turnRight() : this.turnLeft();
        },
        turnLeft: function turnLeft() {
          this.moveActiveIndexDown(1);
        },
        turnRight: function turnRight() {
          this.moveActiveIndexUp(1);
        },
        loadImages: function loadImages() {
          console.log("load image");
        },
        checkMobile: function checkMobile() {
          this.isMobile = !!("ontouchstart" in window || navigator.msMaxTouchPoints);
        },
        loadInitialImage: function loadInitialImage() {
          this.currentImage = this.imageData[0];
          this.setImage();
        },
        resizeWindow: function resizeWindow() {
          this.setImage();
        },
        onPinch: function onPinch(evt) {
          console.log("on tap");
        },
        onPinchEnd: function onPinchEnd(evt) {
          this.tempScale = 0;
        },
        onPinchIn: function onPinchIn(evt) {
          this.zoomOut();
        },
        onPinchOut: function onPinchOut(evt) {
          this.zoomIn();
        },
        attachEvents: function attachEvents() {
          if (this.panmode) {
            this.bindPanModeEvents();
          } else {
            this.bind360ModeEvents();
          }
        },
        bindPanModeEvents: function bindPanModeEvents() {
          this.$refs.viewport.removeEventListener("touchend", this.touchEnd);
          this.$refs.viewport.removeEventListener("touchstart", this.touchStart);
          this.$refs.viewport.removeEventListener("touchmove", this.touchMove);
          this.$refs.viewport.addEventListener("touchend", this.stopDragging);
          this.$refs.viewport.addEventListener("touchstart", this.startDragging);
          this.$refs.viewport.addEventListener("touchmove", this.doDragging);
          this.$refs.viewport.removeEventListener("mouseup", this.stopMoving);
          this.$refs.viewport.removeEventListener("mousedown", this.startMoving);
          this.$refs.viewport.removeEventListener("mousemove", this.doMoving);
          this.$refs.viewport.addEventListener("mouseup", this.stopDragging);
          this.$refs.viewport.addEventListener("mousedown", this.startDragging);
          this.$refs.viewport.addEventListener("mousemove", this.doDragging);
          this.$refs.viewport.addEventListener("wheel", this.onScroll);
        },
        bind360ModeEvents: function bind360ModeEvents() {
          this.$refs.viewport.removeEventListener("touchend", this.stopDragging);
          this.$refs.viewport.removeEventListener("touchstart", this.startDragging);
          this.$refs.viewport.removeEventListener("touchmove", this.doDragging);
          this.$refs.viewport.addEventListener("touchend", this.touchEnd);
          this.$refs.viewport.addEventListener("touchstart", this.touchStart);
          this.$refs.viewport.addEventListener("touchmove", this.touchMove);
          this.$refs.viewport.removeEventListener("mouseup", this.stopDragging);
          this.$refs.viewport.removeEventListener("mousedown", this.startDragging);
          this.$refs.viewport.removeEventListener("mousemove", this.doDragging);
          this.$refs.viewport.addEventListener("mouseup", this.stopMoving);
          this.$refs.viewport.addEventListener("mousedown", this.startMoving);
          this.$refs.viewport.addEventListener("mousemove", this.doMoving);
          this.$refs.viewport.addEventListener("wheel", this.onScroll);
        },
        togglePanMode: function togglePanMode() {
          this.panmode = !this.panmode;
        },
        zoomIn: function zoomIn(evt) {
          if (this.disableZoom) return;
          this.lastX = this.centerX;
          this.lastY = this.centerY;
          this.zoom(2);
        },
        zoomOut: function zoomOut(evt) {
          if (this.disableZoom) return;
          this.lastX = this.centerX;
          this.lastY = this.centerY;
          this.zoom(-2);
        },
        moveLeft: function moveLeft() {
          this.currentLeftPosition += this.customOffset;
        },
        moveRight: function moveRight() {
          this.currentLeftPosition -= this.customOffset;
        },
        moveUp: function moveUp() {
          this.currentTopPosition += this.customOffset;
        },
        moveDown: function moveDown() {
          this.currentTopPosition -= this.customOffset;
        },
        resetPosition: function resetPosition() {
          this.currentScale = 1;
          this.activeImage = 1;
          this.setImage(true);
        },
        setImage: function setImage() {
          var _this3 = this;
          var cached = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          this.currentLeftPosition = this.currentTopPosition = 0;
          if (!cached) {
            this.currentCanvasImage = new Image();
            this.currentCanvasImage.crossOrigin = "anonymous";
            this.currentCanvasImage.src = this.currentImage;
            this.currentCanvasImage.onload = function() {
              var viewportElement2 = _this3.$refs.viewport.getBoundingClientRect();
              _this3.canvas.width = _this3.isFullScreen ? viewportElement2.width : _this3.currentCanvasImage.width;
              _this3.canvas.height = _this3.isFullScreen ? viewportElement2.height : _this3.currentCanvasImage.height;
              _this3.trackTransforms(_this3.ctx);
              _this3.redraw();
            };
            this.currentCanvasImage.onerror = function() {
              console.log("cannot load this image");
            };
          } else {
            this.currentCanvasImage = this.images[0];
            var viewportElement = this.$refs.viewport.getBoundingClientRect();
            this.canvas.width = this.isFullScreen ? viewportElement.width : this.currentCanvasImage.width;
            this.canvas.height = this.isFullScreen ? viewportElement.height : this.currentCanvasImage.height;
            this.trackTransforms(this.ctx);
            this.redraw();
          }
        },
        redraw: function redraw() {
          try {
            var p1 = this.ctx.transformedPoint(0, 0);
            var p2 = this.ctx.transformedPoint(this.canvas.width, this.canvas.height);
            var hRatio = this.canvas.width / this.currentCanvasImage.width;
            var vRatio = this.canvas.height / this.currentCanvasImage.height;
            var ratio = Math.min(hRatio, vRatio);
            var centerShift_x = (this.canvas.width - this.currentCanvasImage.width * ratio) / 2;
            var centerShift_y = (this.canvas.height - this.currentCanvasImage.height * ratio) / 2;
            this.ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
            this.centerX = this.currentCanvasImage.width * ratio / 2;
            this.centerY = this.currentCanvasImage.height * ratio / 2;
            this.ctx.drawImage(this.currentCanvasImage, this.currentLeftPosition, this.currentTopPosition, this.currentCanvasImage.width, this.currentCanvasImage.height, centerShift_x, centerShift_y, this.currentCanvasImage.width * ratio, this.currentCanvasImage.height * ratio);
            this.addHotspots();
          } catch (e) {
            this.trackTransforms(this.ctx);
          }
        },
        addHotspots: function addHotspots() {
          var _this4 = this;
          this.clearHotspots();
          var currentImageHotspots = this.hotspots.filter(function(h) {
            return h.frame == _this4.activeImage;
          });
          var _loop = function _loop2(c2) {
            var hotspotElement = currentImageHotspots[c2];
            var hotspotPositionX = void 0, hotspotPositionY = void 0;
            if (_this4.canvas.width > _this4.$refs.viewport.clientWidth) {
              hotspotPositionX = hotspotElement.x * _this4.$refs.viewport.clientWidth;
              hotspotPositionY = hotspotElement.y * _this4.$refs.viewport.clientHeight;
            } else {
              hotspotPositionX = hotspotElement.x * _this4.canvas.width;
              hotspotPositionY = hotspotElement.y * _this4.canvas.height;
            }
            var divElement = document.createElement("div");
            var spanElement = document.createElement("span");
            var imgElement = document.createElement("img");
            imgElement.className = "hotspot-icon";
            imgElement.src = hotspotElement.icon;
            spanElement.className = "tooltiptext";
            spanElement.innerHTML = hotspotElement.text;
            divElement.className = "tooltip";
            divElement.style.left = hotspotPositionX + "px";
            divElement.style.top = hotspotPositionY + "px";
            divElement.appendChild(imgElement);
            divElement.appendChild(spanElement);
            imgElement.addEventListener("click", function(e) {
              e.preventDefault();
              console.log("show edit hotspot form");
              _this4.selectedHotspot = hotspotElement;
              _this4.openHotspotForm(true);
            });
            if (hotspotElement.action) {
              console.log("add this function: " + hotspotElement.action);
            }
            _this4.$refs.viewport.appendChild(divElement);
          };
          for (var c in currentImageHotspots) {
            _loop(c);
          }
        },
        clearHotspots: function clearHotspots() {
          var hotspotButtons = document.getElementById(this.identifier).querySelectorAll(".tooltip");
          if (hotspotButtons.length) hotspotButtons.forEach(function(element) {
            return element.remove();
          });
        },
        onMove: function onMove(pageX) {
          if (pageX - this.movementStart >= this.speedFactor) {
            var itemsSkippedRight = Math.floor((pageX - this.movementStart) / this.speedFactor) || 1;
            this.movementStart = pageX;
            if (this.spinReverse) {
              this.moveActiveIndexDown(itemsSkippedRight);
            } else {
              this.moveActiveIndexUp(itemsSkippedRight);
            }
            this.redraw();
          } else if (this.movementStart - pageX >= this.speedFactor) {
            var itemsSkippedLeft = Math.floor((this.movementStart - pageX) / this.speedFactor) || 1;
            this.movementStart = pageX;
            if (this.spinReverse) {
              this.moveActiveIndexUp(itemsSkippedLeft);
            } else {
              this.moveActiveIndexDown(itemsSkippedLeft);
            }
            this.redraw();
          }
        },
        startMoving: function startMoving(evt) {
          this.movement = true;
          this.movementStart = evt.pageX;
          this.$refs.viewport.style.cursor = "grabbing";
        },
        doMoving: function doMoving(evt) {
          if (this.movement) {
            this.onMove(evt.clientX);
          }
        },
        onScroll: function onScroll(evt) {
          evt.preventDefault();
          if (this.disableZoom || this.scrollImage) {
            if (evt.deltaY < 0) {
              this.moveActiveIndexDown(1);
            } else {
              this.moveActiveIndexUp(1);
            }
            this.onMove(evt.scrollTop);
          } else {
            this.zoomImage(evt);
          }
        },
        moveActiveIndexUp: function moveActiveIndexUp(itemsSkipped) {
          if (this.stopAtEdges) {
            if (this.activeImage + itemsSkipped >= this.amount) {
              this.activeImage = this.amount;
            } else {
              this.activeImage += itemsSkipped;
            }
          } else {
            this.activeImage = (this.activeImage + itemsSkipped) % this.amount || this.amount;
          }
          this.update();
        },
        moveActiveIndexDown: function moveActiveIndexDown(itemsSkipped) {
          if (this.stopAtEdges) {
            if (this.activeImage - itemsSkipped <= 1) {
              this.activeImage = 1;
            } else {
              this.activeImage -= itemsSkipped;
            }
          } else {
            if (this.activeImage - itemsSkipped < 1) {
              this.activeImage = this.amount + (this.activeImage - itemsSkipped);
            } else {
              this.activeImage -= itemsSkipped;
            }
          }
          this.update();
        },
        update: function update() {
          var image = this.images[this.activeImage - 1];
          this.currentCanvasImage = image;
          this.redraw();
        },
        stopMoving: function stopMoving(evt) {
          this.movement = false;
          this.movementStart = 0;
          this.$refs.viewport.style.cursor = "grab";
        },
        touchStart: function touchStart(evt) {
          this.movementStart = evt.touches[0].clientX;
        },
        touchMove: function touchMove(evt) {
          this.onMove(evt.touches[0].clientX);
        },
        touchEnd: function touchEnd() {
          this.movementStart = 0;
        },
        startDragging: function startDragging(evt) {
          this.dragging = true;
          document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = "none";
          if (this.isMobile) {
            this.lastX = evt.touches[0].offsetX || evt.touches[0].pageX - this.canvas.offsetLeft;
            this.lastY = evt.touches[0].offsetY || evt.touches[0].pageY - this.canvas.offsetTop;
          } else {
            this.lastX = evt.offsetX || evt.pageX - this.canvas.offsetLeft;
            this.lastY = evt.offsetY || evt.pageY - this.canvas.offsetTop;
          }
          this.dragStart = this.ctx.transformedPoint(this.lastX, this.lastY);
        },
        doDragging: function doDragging(evt) {
          if (this.isMobile) {
            this.lastX = evt.touches[0].offsetX || evt.touches[0].pageX - this.canvas.offsetLeft;
            this.lastY = evt.touches[0].offsetY || evt.touches[0].pageY - this.canvas.offsetTop;
          } else {
            this.lastX = evt.offsetX || evt.pageX - this.canvas.offsetLeft;
            this.lastY = evt.offsetY || evt.pageY - this.canvas.offsetTop;
          }
          if (this.dragStart) {
            var pt = this.ctx.transformedPoint(this.lastX, this.lastY);
            this.ctx.translate(pt.x - this.dragStart.x, pt.y - this.dragStart.y);
            this.redraw();
          }
        },
        stopDragging: function stopDragging(evt) {
          this.dragging = false;
          this.dragStart = null;
        },
        restrictScale: function restrictScale() {
          var scale = this.currentScale;
          if (scale < this.minScale) {
            scale = this.minScale;
          } else if (scale > this.maxScale) {
            scale = this.maxScale;
          }
          return scale;
        },
        zoom: function zoom(clicks) {
          var factor = Math.pow(1.01, clicks);
          if (factor > 1) {
            this.currentScale += factor;
          } else {
            if (this.currentScale - factor > 1) this.currentScale -= factor;
            else this.currentScale = 1;
          }
          if (this.currentScale > 1) {
            var pt = this.ctx.transformedPoint(this.lastX, this.lastY);
            this.ctx.translate(pt.x, pt.y);
            this.ctx.scale(factor, factor);
            this.ctx.translate(-pt.x, -pt.y);
            this.redraw();
          }
        },
        zoomImage: function zoomImage(evt) {
          if (this.disableZoom) return;
          this.lastX = evt.offsetX || evt.pageX - this.canvas.offsetLeft;
          this.lastY = evt.offsetY || evt.pageY - this.canvas.offsetTop;
          var delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.deltaY ? -evt.deltaY : 0;
          if (delta) this.zoom(delta);
          return evt.preventDefault() && false;
        },
        trackTransforms: function trackTransforms(ctx) {
          var _this5 = this;
          return new Promise(function(resolve) {
            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            var xform = svg.createSVGMatrix();
            _this5.ctx.getTransform = function() {
              return xform;
            };
            var savedTransforms = [];
            var save = ctx.save;
            _this5.ctx.save = function() {
              savedTransforms.push(xform.translate(0, 0));
              return save.call(_this5.ctx);
            };
            var restore = ctx.restore;
            _this5.ctx.restore = function() {
              xform = savedTransforms.pop();
              return restore.call(_this5.ctx);
            };
            var scale = _this5.ctx.scale;
            _this5.ctx.scale = function(sx, sy) {
              xform = xform.scaleNonUniform(sx, sy);
              return scale.call(_this5.ctx, sx, sy);
            };
            var rotate = _this5.ctx.rotate;
            _this5.ctx.rotate = function(radians) {
              xform = xform.rotate(radians * 180 / Math.PI);
              return rotate.call(_this5.ctx, radians);
            };
            var translate = _this5.ctx.translate;
            _this5.ctx.translate = function(dx, dy) {
              xform = xform.translate(dx, dy);
              return translate.call(_this5.ctx, dx, dy);
            };
            var transform = _this5.ctx.transform;
            _this5.ctx.transform = function(a, b, c, d, e, f2) {
              var m2 = svg.createSVGMatrix();
              m2.a = a;
              m2.b = b;
              m2.c = c;
              m2.d = d;
              m2.e = e;
              m2.f = f2;
              xform = xform.multiply(m2);
              return transform.call(_this5.ctx, a, b, c, d, e, f2);
            };
            var setTransform = _this5.ctx.setTransform;
            _this5.ctx.setTransform = function(a, b, c, d, e, f2) {
              xform.a = a;
              xform.b = b;
              xform.c = c;
              xform.d = d;
              xform.e = e;
              xform.f = f2;
              return setTransform.call(_this5.ctx, a, b, c, d, e, f2);
            };
            var pt = svg.createSVGPoint();
            _this5.ctx.transformedPoint = function(x, y) {
              pt.x = x;
              pt.y = y;
              return pt.matrixTransform(xform.inverse());
            };
            resolve(_this5.ctx);
          });
        },
        toggleFullScreen: function toggleFullScreen() {
          this.isFullScreen = !this.isFullScreen;
        }
      }
    };
    function normalizeComponent(template, style, script2, scopeId, isFunctionalTemplate, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== "boolean") {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
      }
      const options = typeof script2 === "function" ? script2.options : script2;
      if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        if (isFunctionalTemplate) {
          options.functional = true;
        }
      }
      if (scopeId) {
        options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
        hook = function(context) {
          context = context || // cached call
          this.$vnode && this.$vnode.ssrContext || // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        options._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook) {
        if (options.functional) {
          const originalRender = options.render;
          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
      return script2;
    }
    var __vue_script__ = script;
    var __vue_render__ = function __vue_render__2() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", [_c("div", {
        ref: "viewerContainer",
        staticClass: "v360-viewer-container",
        attrs: {
          "id": _vm.identifier
        }
      }, [_vm._t("header"), _vm._v(" "), !_vm.imagesLoaded ? _c("div", {
        staticClass: "v360-viewport"
      }, [_c("div", {
        staticClass: "v360-spinner-grow"
      }), _vm._v(" "), _c("p", {
        ref: "viewPercentage",
        staticClass: "v360-percentage-text"
      })]) : _vm._e(), _vm._v(" "), _c("div", {
        ref: "viewport",
        staticClass: "v360-viewport"
      }, [_c("canvas", {
        directives: [{
          name: "hammer",
          rawName: "v-hammer:pinch",
          value: _vm.onPinch,
          expression: "onPinch",
          arg: "pinch"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchend",
          value: _vm.onPinch,
          expression: "onPinch",
          arg: "pinchend"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchout",
          value: _vm.onPinchOut,
          expression: "onPinchOut",
          arg: "pinchout"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchin",
          value: _vm.onPinchIn,
          expression: "onPinchIn",
          arg: "pinchin"
        }],
        ref: "imageContainer",
        staticClass: "v360-image-container"
      }), _vm._v(" "), _vm.boxShadow ? _c("div", {
        directives: [{
          name: "hammer",
          rawName: "v-hammer:pinch",
          value: _vm.onPinch,
          expression: "onPinch",
          arg: "pinch"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchend",
          value: _vm.onPinch,
          expression: "onPinch",
          arg: "pinchend"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchout",
          value: _vm.onPinchOut,
          expression: "onPinchOut",
          arg: "pinchout"
        }, {
          name: "hammer",
          rawName: "v-hammer:pinchin",
          value: _vm.onPinchIn,
          expression: "onPinchIn",
          arg: "pinchin"
        }],
        staticClass: "v360-product-box-shadow"
      }) : _vm._e()]), _vm._v(" "), _c("abbr", {
        attrs: {
          "title": "Fullscreen Toggle"
        }
      }, [_c("div", {
        staticClass: "v360-fullscreen-toggle text-center",
        on: {
          "click": _vm.toggleFullScreen
        }
      }, [_c("div", {
        staticClass: "v360-fullscreen-toggle-btn",
        class: _vm.buttonClass == "dark" ? "text-light" : "text-dark"
      }, [_c("i", {
        class: !_vm.isFullScreen ? "fas fa-expand text-lg" : "fas fa-compress text-lg"
      })])])]), _vm._v(" "), _c("div", {
        class: _vm.buttonClass,
        attrs: {
          "id": "v360-menu-btns"
        }
      }, [_c("div", {
        staticClass: "v360-navigate-btns"
      }, [_c("div", {
        staticClass: "v360-menu-btns",
        class: _vm.playing ? "v360-btn-active" : "",
        on: {
          "click": _vm.togglePlay
        }
      }, [!_vm.playing ? _c("i", {
        staticClass: "fa fa-play"
      }) : _c("i", {
        staticClass: "fa fa-pause"
      })]), _vm._v(" "), !_vm.disableZoom ? _c("div", {
        staticClass: "v360-menu-btns",
        on: {
          "click": _vm.zoomIn
        }
      }, [_c("i", {
        staticClass: "fa fa-search-plus"
      })]) : _vm._e(), _vm._v(" "), !_vm.disableZoom ? _c("div", {
        staticClass: "v360-menu-btns",
        on: {
          "click": _vm.zoomOut
        }
      }, [_c("i", {
        staticClass: "fa fa-search-minus"
      })]) : _vm._e(), _vm._v(" "), _c("div", {
        staticClass: "v360-menu-btns",
        class: _vm.panmode ? "v360-btn-active" : "",
        on: {
          "click": _vm.togglePanMode
        }
      }, [!_vm.panmode ? _c("i", {
        staticClass: "fa fa-hand-paper"
      }) : _c("span", [_vm._v("360°")])]), _vm._v(" "), _c("div", {
        staticClass: "v360-menu-btns",
        on: {
          "click": _vm.prev
        }
      }, [_c("i", {
        staticClass: "fa fa-chevron-left"
      })]), _vm._v(" "), _c("div", {
        staticClass: "v360-menu-btns",
        on: {
          "click": _vm.next
        }
      }, [_c("i", {
        staticClass: "fa fa-chevron-right"
      })]), _vm._v(" "), _c("div", {
        staticClass: "v360-menu-btns",
        on: {
          "click": _vm.resetPosition
        }
      }, [_c("i", {
        staticClass: "fa fa-sync"
      })])])])], 2)]);
    };
    var __vue_staticRenderFns__ = [];
    var __vue_inject_styles__ = void 0;
    var __vue_scope_id__ = void 0;
    var __vue_module_identifier__ = void 0;
    var __vue_is_functional_template__ = false;
    var __vue_component__ = normalizeComponent({
      render: __vue_render__,
      staticRenderFns: __vue_staticRenderFns__
    }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, void 0, void 0, void 0);
    var _defined = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
    var _toObject = function(it) {
      return Object(_defined(it));
    };
    var hasOwnProperty$1 = {}.hasOwnProperty;
    var _has = function(it, key2) {
      return hasOwnProperty$1.call(it, key2);
    };
    var toString$1 = {}.toString;
    var _cof = function(it) {
      return toString$1.call(it).slice(8, -1);
    };
    var _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return _cof(it) == "String" ? it.split("") : Object(it);
    };
    var _toIobject = function(it) {
      return _iobject(_defined(it));
    };
    var ceil$1 = Math.ceil;
    var floor$2 = Math.floor;
    var _toInteger = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor$2 : ceil$1)(it);
    };
    var min$3 = Math.min;
    var _toLength = function(it) {
      return it > 0 ? min$3(_toInteger(it), 9007199254740991) : 0;
    };
    var max$2 = Math.max;
    var min$4 = Math.min;
    var _toAbsoluteIndex = function(index2, length) {
      index2 = _toInteger(index2);
      return index2 < 0 ? max$2(index2 + length, 0) : min$4(index2, length);
    };
    var _arrayIncludes = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = _toIobject($this);
        var length = _toLength(O.length);
        var index2 = _toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index2) {
          value = O[index2++];
          if (value != value) return true;
        }
        else for (; length > index2; index2++) if (IS_INCLUDES || index2 in O) {
          if (O[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    var _core = createCommonjsModule(function(module2) {
      var core = module2.exports = { version: "2.6.11" };
      if (typeof __e == "number") __e = core;
    });
    var _core_1 = _core.version;
    var _global = createCommonjsModule(function(module2) {
      var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
      if (typeof __g == "number") __g = global2;
    });
    var _shared = createCommonjsModule(function(module2) {
      var SHARED2 = "__core-js_shared__";
      var store2 = _global[SHARED2] || (_global[SHARED2] = {});
      (module2.exports = function(key2, value) {
        return store2[key2] || (store2[key2] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: _core.version,
        mode: "pure",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    });
    var id$1 = 0;
    var px = Math.random();
    var _uid = function(key2) {
      return "Symbol(".concat(key2 === void 0 ? "" : key2, ")_", (++id$1 + px).toString(36));
    };
    var shared$1 = _shared("keys");
    var _sharedKey = function(key2) {
      return shared$1[key2] || (shared$1[key2] = _uid(key2));
    };
    var arrayIndexOf = _arrayIncludes(false);
    var IE_PROTO$1 = _sharedKey("IE_PROTO");
    var _objectKeysInternal = function(object, names) {
      var O = _toIobject(object);
      var i = 0;
      var result = [];
      var key2;
      for (key2 in O) if (key2 != IE_PROTO$1) _has(O, key2) && result.push(key2);
      while (names.length > i) if (_has(O, key2 = names[i++])) {
        ~arrayIndexOf(result, key2) || result.push(key2);
      }
      return result;
    };
    var _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    var _objectKeys = Object.keys || function keys2(O) {
      return _objectKeysInternal(O, _enumBugKeys);
    };
    var _aFunction = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
    var _ctx = function(fn, that, length) {
      _aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
    var _isObject = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
    var _anObject = function(it) {
      if (!_isObject(it)) throw TypeError(it + " is not an object!");
      return it;
    };
    var _fails = function(exec) {
      try {
        return !!exec();
      } catch (e) {
        return true;
      }
    };
    var _descriptors = !_fails(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
    var document$2 = _global.document;
    var is = _isObject(document$2) && _isObject(document$2.createElement);
    var _domCreate = function(it) {
      return is ? document$2.createElement(it) : {};
    };
    var _ie8DomDefine = !_descriptors && !_fails(function() {
      return Object.defineProperty(_domCreate("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
    var _toPrimitive = function(it, S) {
      if (!_isObject(it)) return it;
      var fn, val;
      if (S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !_isObject(val = fn.call(it))) return val;
      if (!S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
    var dP = Object.defineProperty;
    var f$5 = _descriptors ? Object.defineProperty : function defineProperty2(O, P, Attributes) {
      _anObject(O);
      P = _toPrimitive(P, true);
      _anObject(Attributes);
      if (_ie8DomDefine) try {
        return dP(O, P, Attributes);
      } catch (e) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
    var _objectDp = {
      f: f$5
    };
    var _propertyDesc = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    var _hide = _descriptors ? function(object, key2, value) {
      return _objectDp.f(object, key2, _propertyDesc(1, value));
    } : function(object, key2, value) {
      object[key2] = value;
      return object;
    };
    var PROTOTYPE$1 = "prototype";
    var $export = function(type, name, source) {
      var IS_FORCED = type & $export.F;
      var IS_GLOBAL = type & $export.G;
      var IS_STATIC = type & $export.S;
      var IS_PROTO = type & $export.P;
      var IS_BIND = type & $export.B;
      var IS_WRAP = type & $export.W;
      var exports2 = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
      var expProto = exports2[PROTOTYPE$1];
      var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE$1];
      var key2, own, out;
      if (IS_GLOBAL) source = name;
      for (key2 in source) {
        own = !IS_FORCED && target && target[key2] !== void 0;
        if (own && _has(exports2, key2)) continue;
        out = own ? target[key2] : source[key2];
        exports2[key2] = IS_GLOBAL && typeof target[key2] != "function" ? source[key2] : IS_BIND && own ? _ctx(out, _global) : IS_WRAP && target[key2] == out ? function(C) {
          var F = function(a, b, c) {
            if (this instanceof C) {
              switch (arguments.length) {
                case 0:
                  return new C();
                case 1:
                  return new C(a);
                case 2:
                  return new C(a, b);
              }
              return new C(a, b, c);
            }
            return C.apply(this, arguments);
          };
          F[PROTOTYPE$1] = C[PROTOTYPE$1];
          return F;
        }(out) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
        if (IS_PROTO) {
          (exports2.virtual || (exports2.virtual = {}))[key2] = out;
          if (type & $export.R && expProto && !expProto[key2]) _hide(expProto, key2, out);
        }
      }
    };
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    var _export$1 = $export;
    var _objectSap = function(KEY, exec) {
      var fn = (_core.Object || {})[KEY] || Object[KEY];
      var exp = {};
      exp[KEY] = exec(fn);
      _export$1(_export$1.S + _export$1.F * _fails(function() {
        fn(1);
      }), "Object", exp);
    };
    _objectSap("keys", function() {
      return function keys2(it) {
        return _objectKeys(_toObject(it));
      };
    });
    var keys$2 = _core.Object.keys;
    var keys$3 = createCommonjsModule(function(module2) {
      module2.exports = { "default": keys$2, __esModule: true };
    });
    unwrapExports(keys$3);
    var hammer = createCommonjsModule(function(module2) {
      (function(window2, document2, exportName, undefined$1) {
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator, context) {
          var i;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined$1) {
            i = 0;
            while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
            }
          } else {
            for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
          }
        }
        function deprecate(method, name, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
          return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window2.console && (window2.console.warn || window2.console.log);
            if (log) {
              log.call(window2.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined$1 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index2 = 1; index2 < arguments.length; index2++) {
              var source = arguments[index2];
              if (source !== undefined$1 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend = deprecate(function extend2(dest, src, merge2) {
          var keys2 = Object.keys(src);
          var i = 0;
          while (i < keys2.length) {
            if (!merge2 || merge2 && dest[keys2[i]] === undefined$1) {
              dest[keys2[i]] = src[keys2[i]];
            }
            i++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src) {
          return extend(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
          }
          return val;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined$1 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node, parent) {
          while (node) {
            if (node == parent) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }
        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i = 0;
            while (i < src.length) {
              if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                return i;
              }
              i++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key2, sort) {
          var results = [];
          var values = [];
          var i = 0;
          while (i < src.length) {
            var val = key2 ? src[i][key2] : src[i];
            if (inArray(values, val) < 0) {
              results.push(src[i]);
            }
            values[i] = val;
            i++;
          }
          if (sort) {
            if (!key2) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a, b) {
                return a[key2] > b[key2];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i = 0;
          while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i++;
          }
          return undefined$1;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window2;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window2;
        var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined$1;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START = 1;
        var INPUT_MOVE = 2;
        var INPUT_END = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input.prototype = {
          /**
           * should handle the inputEvent data and trigger the callback
           * @virtual
           */
          handler: function() {
          },
          /**
           * bind the events
           */
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          /**
           * unbind the events
           */
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i = 0;
          while (i < input.pointers.length) {
            pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
            };
            i++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
            };
          }
          var x = 0, y = 0, i = 0;
          while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
          }
          return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
          };
        }
        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }
        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }
          if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }
        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP = {
          mousedown: INPUT_START,
          mousemove: INPUT_MOVE,
          mouseup: INPUT_END
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input.apply(this, arguments);
        }
        inherit(MouseInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START,
          pointermove: INPUT_MOVE,
          pointerup: INPUT_END,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
          // see https://twitter.com/jacobrossi/status/480596438489890816
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window2.MSPointerEvent && !window2.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function PEhandler(ev) {
            var store2 = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store2, ev.pointerId, "pointerId");
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store2.push(ev);
                storeIndex = store2.length - 1;
              }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store2[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store2,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store2.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input.apply(this, arguments);
        }
        inherit(TouchInput, Input, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
            }
          }
          i = 0;
          while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
            }
            i++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input, {
          /**
           * handle mouse and touch events
           * @param {Hammer} manager
           * @param {String} inputEvent
           * @param {Object} inputData
           */
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          /**
           * remove the event listeners
           */
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                lts.splice(i, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
          for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }
        TouchAction.prototype = {
          /**
           * set the touchAction value on the element or enable the polyfill
           * @param {String} value
           */
          set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          },
          /**
           * just re-set the touchAction value
           */
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          /**
           * compute the value for the touchAction property based on the recognizer's settings
           * @returns {String} value
           */
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          /**
           * this method is called on each input cycle and provides the preventing of the browser behavior
           * @param {Object} input
           */
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          /**
           * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
           * @param {Object} srcEvent
           */
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window2.CSS && window2.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          /**
           * @virtual
           * @type {Object}
           */
          defaults: {},
          /**
           * set options
           * @param {Object} options
           * @return {Recognizer}
           */
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          /**
           * recognize simultaneous with an other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          /**
           * drop the simultaneous link. it doesnt remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          /**
           * recognizer can only run when an other is failing
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          /**
           * drop the requireFailure link. it does not remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index2 = inArray(this.requireFail, otherRecognizer);
            if (index2 > -1) {
              this.requireFail.splice(index2, 1);
            }
            return this;
          },
          /**
           * has require failures boolean
           * @returns {boolean}
           */
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          /**
           * if the recognizer can recognize simultaneous with an other recognizer
           * @param {Recognizer} otherRecognizer
           * @returns {Boolean}
           */
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          /**
           * You should use `tryEmit` instead of `emit` directly to check
           * that all the needed recognizers has failed before emitting.
           * @param {Object} input
           */
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          /**
           * Check that all the require failure recognizers has failed,
           * if true, it emits a gesture event,
           * otherwise, setup the state to FAILED.
           * @param {Object} input
           */
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          /**
           * can we emit?
           * @returns {boolean}
           */
          canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i++;
            }
            return true;
          },
          /**
           * update the recognizer
           * @param {Object} inputData
           */
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          /**
           * return the state of the recognizer
           * the actual recognizing happens in this method
           * @virtual
           * @param {Object} inputData
           * @returns {Const} STATE
           */
          process: function(inputData) {
          },
          // jshint ignore:line
          /**
           * return the preferred touch-action
           * @virtual
           * @returns {Array}
           */
          getTouchAction: function() {
          },
          /**
           * called when the gesture isn't allowed to recognize
           * like when another is being recognized or it is disabled
           * @virtual
           */
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof AttrRecognizer
           */
          defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
          },
          /**
           * Used to check if it the recognizer receives valid input, like input.distance > 10.
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {Boolean} recognized
           */
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          /**
           * Process the input and return the state for the recognizer
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {*} State
           */
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PanRecognizer
           */
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PressRecognizer
           */
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            // minimal time of the pointer to be pressed
            threshold: 9
            // a minimal movement is ok, but keep it low
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof RotateRecognizer
           */
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof SwipeRecognizer
           */
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            // max time between the multi-tap taps
            time: 250,
            // max time of the pointer to be down (like finger on the screen)
            threshold: 9,
            // a minimal movement is ok, but keep it low
            posThreshold: 10
            // a multi-tap can be a bit off the initial position
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager(element, options);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          /**
           * set if DOM events are being triggered.
           * But this is slower and unused by simple implementations, so disabled by default.
           * @type {Boolean}
           * @default false
           */
          domEvents: false,
          /**
           * The value for the touchAction property/fallback.
           * When set to `compute` it will magically set the correct value based on the added recognizers.
           * @type {String}
           * @default compute
           */
          touchAction: TOUCH_ACTION_COMPUTE,
          /**
           * @type {Boolean}
           * @default true
           */
          enable: true,
          /**
           * EXPERIMENTAL FEATURE -- can be removed/changed
           * Change the parent input target element.
           * If Null, then it is being set the to main element.
           * @type {Null|EventTarget}
           * @default null
           */
          inputTarget: null,
          /**
           * force an input class
           * @type {Null|Function}
           * @default null
           */
          inputClass: null,
          /**
           * Default recognizer setup when calling `Hammer()`
           * When creating a new Manager these will be skipped.
           * @type {Array}
           */
          preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          /**
           * Some CSS properties can be used to improve the working of Hammer.
           * Add them to this method and they will be set when creating a new Manager.
           * @namespace
           */
          cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: "none",
            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: "none",
            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: "none",
            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: "none",
            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: "none",
            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager.prototype = {
          /**
           * set options
           * @param {Object} options
           * @returns {Manager}
           */
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          /**
           * stop recognizing for this session.
           * This session will be discarded, when a new [input]start event is fired.
           * When forced, the recognizer cycle is stopped immediately.
           * @param {Boolean} [force]
           */
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          /**
           * run the recognizers!
           * called by the inputHandler function on every movement of the pointers (touches)
           * it walks through all the recognizers and tries to detect the gesture that is being made
           * @param {Object} inputData
           */
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
              recognizer = recognizers[i];
              if (session.stopped !== FORCED_STOP && // 1
              (!curRecognizer || recognizer == curRecognizer || // 2
              recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
            }
          },
          /**
           * get a recognizer by its event name.
           * @param {Recognizer|String} recognizer
           * @returns {Recognizer|Null}
           */
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
              }
            }
            return null;
          },
          /**
           * add a recognizer to the manager
           * existing recognizers with the same event name will be removed
           * @param {Recognizer} recognizer
           * @returns {Recognizer|Manager}
           */
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          /**
           * remove a recognizer by name or instance
           * @param {Recognizer|String} recognizer
           * @returns {Manager}
           */
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index2 = inArray(recognizers, recognizer);
              if (index2 !== -1) {
                recognizers.splice(index2, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          /**
           * bind event
           * @param {String} events
           * @param {Function} handler
           * @returns {EventEmitter} this
           */
          on: function(events, handler) {
            if (events === undefined$1) {
              return;
            }
            if (handler === undefined$1) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          /**
           * unbind event, leave emit blank to remove all handlers
           * @param {String} events
           * @param {Function} [handler]
           * @returns {EventEmitter} this
           */
          off: function(events, handler) {
            if (events === undefined$1) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          /**
           * emit event to the listeners
           * @param {String} event
           * @param {Object} data
           */
          emit: function(event, data2) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data2);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data2.type = event;
            data2.preventDefault = function() {
              data2.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
              handlers[i](data2);
              i++;
            }
          },
          /**
           * destroy the manager and unbinds all events
           * it doesn't unbind dom events, that is the user own responsibility
           */
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data2) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data2;
          data2.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
          INPUT_START,
          INPUT_MOVE,
          INPUT_END,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager,
          Input,
          TouchAction,
          TouchInput,
          MouseInput,
          PointerEventInput,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (typeof undefined$1 === "function" && undefined$1.amd) {
          undefined$1(function() {
            return Hammer;
          });
        } else if (module2.exports) {
          module2.exports = Hammer;
        } else {
          window2[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    });
    var index_min = createCommonjsModule(function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VueHammer = void 0;
      var _keys2 = _interopRequireDefault(keys$3);
      var _hammerjs2 = _interopRequireDefault(hammer);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var gestures = ["tap", "pan", "pinch", "press", "rotate", "swipe"];
      var subGestures = ["panstart", "panend", "panmove", "pancancel", "pinchstart", "pinchmove", "pinchend", "pinchcancel", "pinchin", "pinchout", "pressup", "rotatestart", "rotatemove", "rotateend", "rotatecancel"];
      var directions = ["up", "down", "left", "right", "horizontal", "vertical", "all"];
      var VueHammer = exports2.VueHammer = { config: {}, customEvents: {}, install: function install(Vue) {
        var _this = this;
        Vue.directive("hammer", { bind: function bind(el, binding) {
          if (!el.hammer) {
            el.hammer = new _hammerjs2.default.Manager(el);
          }
          var mc = el.hammer;
          var event = binding.arg;
          if (!event) {
            console.warn("[vue-hammer] event type argument is required.");
          }
          el.__hammerConfig = el.__hammerConfig || {};
          el.__hammerConfig[event] = {};
          var direction = binding.modifiers;
          el.__hammerConfig[event].direction = el.__hammerConfig[event].direction || [];
          if ((0, _keys2.default)(direction).length) {
            (0, _keys2.default)(direction).filter(function(keyName) {
              return binding.modifiers[keyName];
            }).forEach(function(keyName) {
              var elDirectionArray = el.__hammerConfig[event].direction;
              if (elDirectionArray.indexOf(keyName) === -1) {
                elDirectionArray.push(String(keyName));
              }
            });
          }
          var recognizerType = void 0, recognizer = void 0;
          if (_this.customEvents[event]) {
            var custom = _this.customEvents[event];
            recognizerType = custom.type;
            recognizer = new _hammerjs2.default[_this.capitalize(recognizerType)](custom);
            recognizer.recognizeWith(mc.recognizers);
            mc.add(recognizer);
          } else {
            recognizerType = gestures.find(function(gesture) {
              return gesture === event;
            });
            var subGesturesType = subGestures.find(function(gesture) {
              return gesture === event;
            });
            if (!recognizerType && !subGesturesType) {
              console.warn("[vue-hammer] invalid event type: " + event);
              return;
            }
            if (subGesturesType && el.__hammerConfig[subGesturesType].direction.length !== 0) {
              console.warn("[vue-hammer] " + subGesturesType + " should not have directions");
            }
            if (!recognizerType) {
              return;
            }
            if (recognizerType === "tap" || recognizerType === "pinch" || recognizerType === "press" || recognizerType === "rotate") {
              if (el.__hammerConfig[recognizerType].direction.length !== 0) {
                throw Error("[vue-hammer] " + recognizerType + " should not have directions");
              }
            }
            recognizer = mc.get(recognizerType);
            if (!recognizer) {
              recognizer = new _hammerjs2.default[_this.capitalize(recognizerType)]();
              recognizer.recognizeWith(mc.recognizers);
              mc.add(recognizer);
            }
            var globalOptions = _this.config[recognizerType];
            if (globalOptions) {
              _this.guardDirections(globalOptions);
              recognizer.set(globalOptions);
            }
            var localOptions = el.hammerOptions && el.hammerOptions[recognizerType];
            if (localOptions) {
              _this.guardDirections(localOptions);
              recognizer.set(localOptions);
            }
          }
        }, inserted: function inserted(el, binding) {
          var mc = el.hammer;
          var event = binding.arg;
          var eventWithDir = subGestures.find(function(subGes) {
            return subGes === event;
          }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction);
          if (mc.handler) {
            mc.off(eventWithDir, mc.handler);
          }
          if (typeof binding.value !== "function") {
            mc.handler = null;
            console.warn("[vue-hammer] invalid handler function for v-hammer: " + binding.arg);
          } else {
            mc.on(eventWithDir, mc.handler = binding.value);
          }
        }, componentUpdated: function componentUpdated(el, binding) {
          var mc = el.hammer;
          var event = binding.arg;
          var eventWithDir = subGestures.find(function(subGes) {
            return subGes === event;
          }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction);
          if (mc.handler) {
            mc.off(eventWithDir, mc.handler);
          }
          if (typeof binding.value !== "function") {
            mc.handler = null;
            console.warn("[vue-hammer] invalid handler function for v-hammer: " + binding.arg);
          } else {
            mc.on(eventWithDir, mc.handler = binding.value);
          }
        }, unbind: function unbind(el, binding) {
          var mc = el.hammer;
          var event = binding.arg;
          var eventWithDir = subGestures.find(function(subGes) {
            return subGes === event;
          }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction);
          if (mc.handler) {
            el.hammer.off(eventWithDir, mc.handler);
          }
          if (!(0, _keys2.default)(mc.handlers).length) {
            el.hammer.destroy();
            el.hammer = null;
          }
        } });
      }, guardDirections: function guardDirections(options) {
        var dir = options.direction;
        if (typeof dir === "string") {
          var hammerDirection = "DIRECTION_" + dir.toUpperCase();
          if (directions.indexOf(dir) > -1 && _hammerjs2.default.hasOwnProperty(hammerDirection)) {
            options.direction = _hammerjs2.default[hammerDirection];
          } else {
            console.warn("[vue-hammer] invalid direction: " + dir);
          }
        }
      }, buildEventWithDirections: function buildEventWithDirections(eventName, directionArray) {
        var f2 = {};
        directionArray.forEach(function(dir) {
          dir = dir.toLowerCase();
          if (dir === "horizontal") {
            f2.left = 1;
            f2.right = 1;
          } else if (dir === "vertical") {
            f2.up = 1;
            f2.down = 1;
          } else if (dir === "all") {
            f2.left = 1;
            f2.right = 1;
            f2.up = 1;
            f2.down = 1;
          } else {
            f2[dir] = 1;
          }
        });
        var _directionArray = (0, _keys2.default)(f2);
        if (_directionArray.length === 0) {
          return eventName;
        }
        var eventWithDirArray = _directionArray.map(function(dir) {
          return eventName + dir;
        });
        return eventWithDirArray.join(" ");
      }, capitalize: function capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      } };
    });
    unwrapExports(index_min);
    var index_min_1 = index_min.VueHammer;
    var index = {
      install: function install(Vue, options) {
        Vue.component("vue-three-sixty", __vue_component__);
        Vue.use(index_min_1);
      }
    };
    module.exports = index;
  }
});
export default require_dist();
/*! Bundled license information:

vue-360/dist/index.js:
  (*!
   * vue-360 v0.1.6
   * (c) Rajeev R. Gade <rajeevgade@gmail.com>
   * Released under the MIT License.
   *)
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=vue-360.js.map
